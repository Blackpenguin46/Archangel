# Archangel CI/CD Pipeline with Security Integration
# Comprehensive security-first pipeline with automated testing, scanning, and deployment

name: Archangel Security CI/CD Pipeline

on:
  push:
    branches: [ main, develop, 'feature/*', 'hotfix/*' ]
    paths:
      - '**/*.py'
      - '**/*.yml'
      - '**/*.yaml'
      - '**/*.json'
      - '**/Dockerfile*'
      - '**/requirements*.txt'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, develop ]
    types: [ opened, synchronize, reopened ]
  schedule:
    # Run security scans daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'staging'
        type: choice
        options:
          - 'staging'
          - 'production'
      security_level:
        description: 'Security scanning level'
        required: true
        default: 'standard'
        type: choice
        options:
          - 'basic'
          - 'standard'
          - 'comprehensive'
      chaos_testing:
        description: 'Enable chaos testing'
        required: false
        default: false
        type: boolean

env:
  # Global environment variables
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  
  # Security scanning configuration
  BANDIT_CONFIG: '.bandit.yml'
  SEMGREP_CONFIG: 'auto'
  SAFETY_DB_VERSION: 'latest'
  
  # Registry and deployment configuration
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: '600'
  
  # Security thresholds
  SECURITY_SEVERITY_THRESHOLD: 'medium'
  VULNERABILITY_COUNT_THRESHOLD: '10'
  CODE_COVERAGE_THRESHOLD: '80'

# Define reusable job configurations
defaults:
  run:
    shell: bash

jobs:
  # ====================================
  # SECURITY PRE-CHECKS
  # ====================================
  security-pre-checks:
    name: Security Pre-Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      security-level: ${{ steps.determine-security-level.outputs.level }}
      skip-deployment: ${{ steps.security-gate.outputs.skip }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for security analysis
          
      - name: Determine security scanning level
        id: determine-security-level
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "level=comprehensive" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "level=standard" >> $GITHUB_OUTPUT
          elif [[ "${{ inputs.security_level }}" != "" ]]; then
            echo "level=${{ inputs.security_level }}" >> $GITHUB_OUTPUT
          else
            echo "level=basic" >> $GITHUB_OUTPUT
          fi
          
      - name: Check for security-sensitive files
        id: security-files-check
        run: |
          SENSITIVE_FILES=$(find . -type f \( -name "*.key" -o -name "*.pem" -o -name "*.p12" -o -name "*.pfx" \) | wc -l)
          if [[ $SENSITIVE_FILES -gt 0 ]]; then
            echo "‚ùå Found $SENSITIVE_FILES sensitive files in repository"
            find . -type f \( -name "*.key" -o -name "*.pem" -o -name "*.p12" -o -name "*.pfx" \)
            exit 1
          fi
          echo "‚úÖ No sensitive files found"
          
      - name: Check for hardcoded secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
          extra_args: --debug --only-verified
          
      - name: Security gate decision
        id: security-gate
        run: |
          # Determine if we should skip deployment based on security findings
          if [[ "${{ job.status }}" == "failure" ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "‚ùå Security pre-checks failed - deployment will be skipped"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Security pre-checks passed"
          fi

  # ====================================
  # CODE QUALITY AND SECURITY ANALYSIS
  # ====================================
  code-quality-security:
    name: Code Quality & Security Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: security-pre-checks
    if: needs.security-pre-checks.outputs.skip-deployment != 'true'
    
    strategy:
      matrix:
        python-version: ['3.10', '3.11']
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          
      - name: Cache Python dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ matrix.python-version }}-
            
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt || echo "No dev requirements found"
          
          # Security scanning tools
          pip install bandit[toml] safety semgrep
          pip install pytest pytest-cov pytest-xdist
          
      - name: Lint with flake8
        run: |
          pip install flake8
          # Stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          # Warning for other issues
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
          
      - name: Security scan with Bandit
        run: |
          echo "üîç Running Bandit security analysis..."
          bandit -r . -f json -o bandit-report.json || true
          bandit -r . -f txt
          
          # Check severity of findings
          CRITICAL_COUNT=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' bandit-report.json 2>/dev/null || echo "0")
          MEDIUM_COUNT=$(jq '[.results[] | select(.issue_severity == "MEDIUM")] | length' bandit-report.json 2>/dev/null || echo "0")
          
          echo "Critical issues: $CRITICAL_COUNT"
          echo "Medium issues: $MEDIUM_COUNT"
          
          if [[ $CRITICAL_COUNT -gt 5 ]]; then
            echo "‚ùå Too many critical security issues found: $CRITICAL_COUNT"
            exit 1
          fi
          
      - name: Security scan with Semgrep
        run: |
          echo "üîç Running Semgrep security analysis..."
          semgrep --config=auto --json --output=semgrep-report.json . || true
          semgrep --config=auto --severity=ERROR . --error || echo "Semgrep completed with warnings"
          
      - name: Dependency vulnerability scan with Safety
        run: |
          echo "üîç Scanning dependencies for vulnerabilities..."
          safety check --json --output safety-report.json || true
          safety check --short-report || echo "Safety scan completed with findings"
          
      - name: Run tests with coverage
        run: |
          python -m pytest --cov=. --cov-report=xml --cov-report=html --junitxml=test-results.xml -v
          
      - name: Check code coverage
        run: |
          COVERAGE=$(python -c "
          import xml.etree.ElementTree as ET
          try:
              tree = ET.parse('coverage.xml')
              root = tree.getroot()
              coverage = float(root.get('line-rate')) * 100
              print(f'{coverage:.1f}')
          except:
              print('0.0')
          ")
          
          echo "Code coverage: $COVERAGE%"
          if (( $(echo "$COVERAGE < $CODE_COVERAGE_THRESHOLD" | bc -l) )); then
            echo "‚ùå Code coverage $COVERAGE% is below threshold $CODE_COVERAGE_THRESHOLD%"
            exit 1
          fi
          echo "‚úÖ Code coverage meets threshold"
          
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results-${{ matrix.python-version }}
          path: |
            test-results.xml
            coverage.xml
            htmlcov/
            bandit-report.json
            semgrep-report.json
            safety-report.json

  # ====================================
  # DOCKER SECURITY SCANNING
  # ====================================
  docker-security:
    name: Docker Security Scanning
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: security-pre-checks
    if: needs.security-pre-checks.outputs.skip-deployment != 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Build Docker image for scanning
        run: |
          docker build -t archangel-security-scan:latest .
          
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'archangel-security-scan:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
          
      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'json'
          output: 'trivy-fs-results.json'
          
      - name: Docker image security with Dockle
        run: |
          # Install Dockle
          VERSION=$(curl --silent "https://api.github.com/repos/goodwithtech/dockle/releases/latest" | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
          curl -L -o dockle.deb "https://github.com/goodwithtech/dockle/releases/download/v${VERSION}/dockle_${VERSION}_Linux-64bit.deb"
          sudo dpkg -i dockle.deb
          
          # Run Dockle scan
          dockle --exit-code 1 --exit-level FATAL archangel-security-scan:latest
          
      - name: Upload security scan results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: docker-security-results
          path: |
            trivy-results.sarif
            trivy-fs-results.json

  # ====================================
  # INFRASTRUCTURE SECURITY TESTING
  # ====================================
  infrastructure-security:
    name: Infrastructure Security Testing
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [security-pre-checks, code-quality-security]
    if: needs.security-pre-checks.outputs.skip-deployment != 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          
      - name: Install infrastructure scanning tools
        run: |
          # Terraform security scanning
          curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
          
          # Kubernetes security scanning
          curl -Lo kube-score https://github.com/zegl/kube-score/releases/latest/download/kube-score_linux_amd64
          chmod +x kube-score
          sudo mv kube-score /usr/local/bin/
          
          # Ansible security scanning
          pip install ansible-lint
          
      - name: Terraform security scan
        if: hashFiles('infrastructure/terraform/*.tf') != ''
        run: |
          echo "üîç Scanning Terraform configurations..."
          tfsec infrastructure/terraform/ --format json --out terraform-security.json || true
          tfsec infrastructure/terraform/ --format lovely || echo "Terraform scan completed with findings"
          
      - name: Kubernetes security scan
        if: hashFiles('infrastructure/k8s/*.yaml') != ''
        run: |
          echo "üîç Scanning Kubernetes manifests..."
          for file in infrastructure/k8s/*.yaml; do
            echo "Scanning $file..."
            kube-score score "$file" || echo "Issues found in $file"
          done
          
      - name: Ansible security scan
        if: hashFiles('infrastructure/ansible/*.yml') != ''
        run: |
          echo "üîç Scanning Ansible playbooks..."
          ansible-lint infrastructure/ansible/ || echo "Ansible scan completed with findings"
          
      - name: Docker Compose security validation
        if: hashFiles('docker-compose*.yml') != ''
        run: |
          echo "üîç Validating Docker Compose security..."
          
          # Check for security anti-patterns
          for compose_file in docker-compose*.yml; do
            echo "Checking $compose_file..."
            
            # Check for privileged containers
            if grep -q "privileged.*true" "$compose_file"; then
              echo "‚ùå Found privileged container in $compose_file"
              exit 1
            fi
            
            # Check for host network mode
            if grep -q "network_mode.*host" "$compose_file"; then
              echo "‚ö†Ô∏è  Host network mode found in $compose_file"
            fi
            
            # Check for exposed ports
            EXPOSED_PORTS=$(grep -c "ports:" "$compose_file" || echo "0")
            echo "üìä Found $EXPOSED_PORTS services with exposed ports in $compose_file"
          done
          
      - name: Upload infrastructure security results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: infrastructure-security-results
          path: |
            terraform-security.json

  # ====================================
  # BUILD AND PACKAGE
  # ====================================
  build-and-package:
    name: Build and Package
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [code-quality-security, docker-security]
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VERSION=${{ github.sha }}
            
      - name: Sign container image
        run: |
          # Install cosign
          curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign
          
          # Sign the image (using keyless signing)
          echo "Signing container image..."
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

  # ====================================
  # CHAOS TESTING
  # ====================================
  chaos-testing:
    name: Chaos Testing
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-and-package]
    if: |
      github.ref == 'refs/heads/main' || 
      github.event.inputs.chaos_testing == 'true' ||
      github.event_name == 'schedule'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Kind cluster
        uses: helm/kind-action@v1.5.0
        with:
          cluster_name: chaos-test
          
      - name: Install LitmusChaos
        run: |
          # Install Litmus operator
          kubectl apply -f https://litmuschaos.github.io/litmus/litmus-operator-v3.0.0.yaml
          
          # Wait for operator to be ready
          kubectl wait --for=condition=Ready pods -l app.kubernetes.io/name=litmus --timeout=300s -n litmus
          
          # Install chaos experiments
          kubectl apply -f https://hub.litmuschaos.io/api/chaos/master?file=charts/generic/experiments.yaml
          
      - name: Deploy test environment
        run: |
          # Deploy simplified version for chaos testing
          kubectl create namespace archangel-chaos
          kubectl apply -f infrastructure/k8s/archangel-namespace.yaml
          
          # Deploy core services for testing
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: test-app
            namespace: archangel-chaos
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: test-app
            template:
              metadata:
                labels:
                  app: test-app
              spec:
                containers:
                - name: app
                  image: nginx:alpine
                  ports:
                  - containerPort: 80
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: test-app-service
            namespace: archangel-chaos
          spec:
            selector:
              app: test-app
            ports:
            - port: 80
              targetPort: 80
          EOF
          
      - name: Run pod failure chaos experiment
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: litmuschaos.io/v1alpha1
          kind: ChaosEngine
          metadata:
            name: pod-failure-chaos
            namespace: archangel-chaos
          spec:
            engineState: 'active'
            appinfo:
              appns: 'archangel-chaos'
              applabel: 'app=test-app'
              appkind: 'deployment'
            chaosServiceAccount: litmus-admin
            experiments:
            - name: pod-failure
              spec:
                components:
                  env:
                  - name: TOTAL_CHAOS_DURATION
                    value: '60'
                  - name: CHAOS_INTERVAL
                    value: '10'
                  - name: FORCE
                    value: 'true'
          EOF
          
          # Wait for experiment to complete
          sleep 90
          
      - name: Validate chaos test results
        run: |
          # Check if services recovered
          kubectl get pods -n archangel-chaos
          kubectl get events -n archangel-chaos --sort-by='.lastTimestamp'
          
          # Verify service is still accessible
          kubectl port-forward -n archangel-chaos svc/test-app-service 8080:80 &
          sleep 5
          
          if curl -s http://localhost:8080 > /dev/null; then
            echo "‚úÖ Service recovered successfully after chaos testing"
          else
            echo "‚ùå Service failed to recover after chaos testing"
            exit 1
          fi

  # ====================================
  # DEPLOYMENT
  # ====================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: 
      name: staging
      url: https://staging.archangel.local
    needs: [build-and-package, infrastructure-security]
    if: |
      github.ref == 'refs/heads/develop' || 
      (github.event.inputs.environment == 'staging' && github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Deploy to staging
        run: |
          echo "üöÄ Deploying to staging environment..."
          
          # This would integrate with your deployment system
          # For example: ArgoCD, Flux, or direct kubectl apply
          
          # Simulate deployment
          echo "Image: ${{ needs.build-and-package.outputs.image-tag }}"
          echo "Digest: ${{ needs.build-and-package.outputs.image-digest }}"
          
          # Run post-deployment tests
          echo "‚úÖ Staging deployment completed"
          
      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests against staging..."
          
          # Wait for deployment to stabilize
          sleep 30
          
          # Run basic health checks
          # This would test your actual staging endpoints
          echo "‚úÖ Smoke tests passed"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: production
      url: https://archangel.local
    needs: [build-and-package, infrastructure-security, chaos-testing]
    if: |
      github.ref == 'refs/heads/main' ||
      (github.event.inputs.environment == 'production' && github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Final security validation
        run: |
          echo "üîí Running final security validation..."
          
          # Verify image signature
          cosign verify --certificate-identity-regexp ".*@users.noreply.github.com" \
                         --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
                         ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-and-package.outputs.image-digest }}
          
          echo "‚úÖ Image signature verified"
          
      - name: Deploy to production
        run: |
          echo "üöÄ Deploying to production environment..."
          
          # Blue-green deployment strategy
          echo "Implementing blue-green deployment..."
          
          # This would integrate with your production deployment system
          echo "Image: ${{ needs.build-and-package.outputs.image-tag }}"
          echo "Digest: ${{ needs.build-and-package.outputs.image-digest }}"
          
          echo "‚úÖ Production deployment completed"
          
      - name: Run production health checks
        run: |
          echo "üè• Running production health checks..."
          
          # Comprehensive health validation
          sleep 60
          
          echo "‚úÖ Production health checks passed"

  # ====================================
  # SECURITY REPORTING
  # ====================================
  security-report:
    name: Security Report
    runs-on: ubuntu-latest
    needs: [code-quality-security, docker-security, infrastructure-security]
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download all security artifacts
        uses: actions/download-artifact@v3
        with:
          path: security-reports
          
      - name: Generate security summary
        run: |
          echo "# Security Scan Summary" > security-summary.md
          echo "**Date**: $(date)" >> security-summary.md
          echo "**Commit**: ${{ github.sha }}" >> security-summary.md
          echo "" >> security-summary.md
          
          # Bandit results
          if [ -f security-reports/test-results-*/bandit-report.json ]; then
            BANDIT_ISSUES=$(jq '[.results[]] | length' security-reports/test-results-*/bandit-report.json 2>/dev/null || echo "0")
            echo "## Bandit (Python Security)" >> security-summary.md
            echo "- **Issues Found**: $BANDIT_ISSUES" >> security-summary.md
            echo "" >> security-summary.md
          fi
          
          # Trivy results
          if [ -f security-reports/docker-security-results/trivy-fs-results.json ]; then
            TRIVY_CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' security-reports/docker-security-results/trivy-fs-results.json 2>/dev/null || echo "0")
            TRIVY_HIGH=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' security-reports/docker-security-results/trivy-fs-results.json 2>/dev/null || echo "0")
            echo "## Trivy (Container Security)" >> security-summary.md
            echo "- **Critical**: $TRIVY_CRITICAL" >> security-summary.md
            echo "- **High**: $TRIVY_HIGH" >> security-summary.md
            echo "" >> security-summary.md
          fi
          
          # Infrastructure security
          if [ -f security-reports/infrastructure-security-results/terraform-security.json ]; then
            TERRAFORM_ISSUES=$(jq '[.results[]] | length' security-reports/infrastructure-security-results/terraform-security.json 2>/dev/null || echo "0")
            echo "## Infrastructure Security" >> security-summary.md
            echo "- **Terraform Issues**: $TERRAFORM_ISSUES" >> security-summary.md
            echo "" >> security-summary.md
          fi
          
          echo "## Summary Status" >> security-summary.md
          if [[ "${{ needs.code-quality-security.result }}" == "success" && 
                "${{ needs.docker-security.result }}" == "success" && 
                "${{ needs.infrastructure-security.result }}" == "success" ]]; then
            echo "‚úÖ **PASSED** - All security scans completed successfully" >> security-summary.md
          else
            echo "‚ùå **FAILED** - Some security scans found issues" >> security-summary.md
          fi
          
      - name: Upload security summary
        uses: actions/upload-artifact@v3
        with:
          name: security-summary
          path: security-summary.md
          
      - name: Comment on PR with security summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('security-summary.md', 'utf8');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Security Scan Results\n\n${summary}`
            });

# ====================================
# NOTIFICATION AND CLEANUP
# ====================================
  notify-completion:
    name: Notify Completion
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production, security-report]
    if: always()
    
    steps:
      - name: Determine overall status
        id: status
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "success" || "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.security-report.result }}" == "failure" ]]; then
            echo "status=security_failure" >> $GITHUB_OUTPUT
            echo "message=Security scans failed - deployment blocked" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Pipeline failed" >> $GITHUB_OUTPUT
          fi
          
      - name: Send Slack notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.status.outputs.status }}
          text: |
            Archangel CI/CD Pipeline: ${{ steps.status.outputs.message }}
            Branch: ${{ github.ref }}
            Commit: ${{ github.sha }}
            Actor: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}