"""
Dynamic Vulnerability Generation and Adaptive Hardening Engine
Self-evolving enterprise environment that adapts based on AI attacks
"""

import asyncio
import logging
import json
import random
import string
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from collections import deque, defaultdict
from datetime import datetime, timedelta
from enum import Enum
import hashlib
import numpy as np
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    INJECTION = "injection"
    BROKEN_AUTH = "broken_authentication"
    SENSITIVE_DATA = "sensitive_data_exposure"
    XXE = "xml_external_entities"
    BROKEN_ACCESS = "broken_access_control"
    SECURITY_MISCONFIG = "security_misconfiguration"
    XSS = "cross_site_scripting"
    INSECURE_DESERIAL = "insecure_deserialization"
    KNOWN_VULNS = "known_vulnerabilities"
    INSUFFICIENT_LOG = "insufficient_logging"
    CRYPTO_FAILURES = "cryptographic_failures"
    SSRF = "server_side_request_forgery"
    
class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"

class HardeningMeasure(Enum):
    PATCH_MANAGEMENT = "patch_management"
    ACCESS_CONTROL = "access_control"
    NETWORK_SEGMENTATION = "network_segmentation"
    ENCRYPTION = "encryption"
    MONITORING = "monitoring"
    INPUT_VALIDATION = "input_validation"
    AUTHENTICATION = "authentication"
    FIREWALL_RULES = "firewall_rules"
    INTRUSION_DETECTION = "intrusion_detection"
    BACKUP_RECOVERY = "backup_recovery"

@dataclass
class GeneratedVulnerability:
    """Dynamically generated vulnerability"""
    vuln_id: str
    vuln_type: VulnerabilityType
    severity: VulnerabilitySeverity
    affected_service: str
    affected_host: str
    description: str
    exploit_complexity: float  # 0-1 scale
    discovery_difficulty: float  # 0-1 scale
    payload_template: str
    prerequisites: List[str]
    post_exploit_actions: List[str]
    cvss_score: float
    generation_method: str
    parent_attack: Optional[str]
    created_at: datetime
    exploited_count: int = 0
    detection_count: int = 0

@dataclass
class AdaptiveHardening:
    """Adaptive security hardening measure"""
    hardening_id: str
    measure_type: HardeningMeasure
    target_vulnerability: str
    implementation_cost: float
    effectiveness_score: float
    deployment_time: float
    side_effects: List[str]
    configuration: Dict[str, Any]
    success_rate: float
    applied_at: datetime
    trigger_event: str

@dataclass
class ThreatIntelligence:
    """Threat intelligence data for vulnerability generation"""
    ttp_patterns: List[str]
    attack_chains: List[List[str]]
    common_payloads: List[str]
    evasion_techniques: List[str]
    target_preferences: Dict[str, float]
    timing_patterns: Dict[str, float]

class DynamicVulnerabilityEngine:
    """Engine for generating vulnerabilities based on attack patterns"""
    
    def __init__(self):
        self.active_vulnerabilities = {}
        self.vulnerability_history = deque(maxlen=10000)
        self.attack_pattern_db = defaultdict(list)
        self.generation_templates = self._initialize_templates()
        self.threat_intelligence = ThreatIntelligence(
            ttp_patterns=[],
            attack_chains=[],
            common_payloads=[],
            evasion_techniques=[],
            target_preferences={},
            timing_patterns={}
        )
        
        # AI-driven generation parameters
        self.novelty_threshold = 0.7
        self.realism_weight = 0.8
        self.difficulty_progression = 0.05
        
        logger.info("Dynamic Vulnerability Engine initialized")
    
    def _initialize_templates(self) -> Dict[VulnerabilityType, Dict[str, Any]]:
        """Initialize vulnerability generation templates"""
        return {
            VulnerabilityType.INJECTION: {
                'base_payload': "'; DROP TABLE users; --",
                'variations': ['union_select', 'blind_boolean', 'time_based', 'error_based'],
                'target_services': ['mysql', 'postgresql', 'mssql', 'web_app'],
                'complexity_factors': ['waf_bypass', 'encoding', 'filter_evasion']
            },
            
            VulnerabilityType.XSS: {
                'base_payload': "<script>alert('XSS')</script>",
                'variations': ['reflected', 'stored', 'dom_based', 'blind'],
                'target_services': ['http', 'web_app', 'api'],
                'complexity_factors': ['csp_bypass', 'filter_evasion', 'encoding']
            },
            
            VulnerabilityType.BROKEN_AUTH: {
                'base_payload': "admin:admin",
                'variations': ['weak_passwords', 'session_fixation', 'jwt_bypass', 'oauth_flaw'],
                'target_services': ['web_app', 'api', 'sso'],
                'complexity_factors': ['mfa_bypass', 'token_manipulation', 'timing_attack']
            },
            
            VulnerabilityType.SSRF: {
                'base_payload': "http://localhost:8080/admin",
                'variations': ['url_bypass', 'protocol_smuggling', 'dns_rebinding'],
                'target_services': ['web_app', 'microservice', 'api'],
                'complexity_factors': ['blacklist_bypass', 'encoding', 'redirect_chains']
            },
            
            VulnerabilityType.INSECURE_DESERIAL: {
                'base_payload': "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABdAABYXQAAWJ4",
                'variations': ['java_serial', 'python_pickle', 'php_unserialize', 'json_rce'],
                'target_services': ['java_app', 'python_app', 'php_app', 'api'],
                'complexity_factors': ['gadget_chains', 'filter_bypass', 'encoding']
            }
        }
    
    async def generate_vulnerability_from_attack(self, attack_pattern: Dict[str, Any], 
                                               network_state: Dict[str, Any]) -> Optional[GeneratedVulnerability]:
        """Generate a new vulnerability based on observed attack patterns"""
        
        # Analyze attack pattern
        attack_type = self._classify_attack_type(attack_pattern)
        target_service = attack_pattern.get('target_service', 'unknown')
        target_host = attack_pattern.get('target_host', 'unknown')
        
        # Determine if we should generate a new vulnerability
        if not self._should_generate_vulnerability(attack_pattern):
            return None
        
        # Generate vulnerability based on attack type
        vuln_type = self._map_attack_to_vulnerability_type(attack_type)
        template = self.generation_templates.get(vuln_type)
        
        if not template:
            logger.warning(f"No template found for vulnerability type: {vuln_type}")
            return None
        
        # Create unique vulnerability
        vuln_id = self._generate_vulnerability_id(attack_pattern)
        
        # Generate realistic vulnerability details
        vulnerability = await self._create_realistic_vulnerability(
            vuln_id, vuln_type, template, target_service, target_host, attack_pattern
        )
        
        # Store in active vulnerabilities
        self.active_vulnerabilities[vuln_id] = vulnerability
        self.vulnerability_history.append(vulnerability)
        
        # Update threat intelligence
        await self._update_threat_intelligence(attack_pattern, vulnerability)
        
        logger.info(f"Generated vulnerability {vuln_id} ({vuln_type.value}) "
                   f"on {target_host}:{target_service}")
        
        return vulnerability
    
    def _classify_attack_type(self, attack_pattern: Dict[str, Any]) -> str:
        """Classify the type of attack from the pattern"""
        action_type = attack_pattern.get('action_type', '').lower()
        tools_used = attack_pattern.get('tools', [])
        target = attack_pattern.get('target', '').lower()
        
        # Rule-based classification
        if 'sql' in action_type or 'sqlmap' in tools_used:
            return 'sql_injection'
        elif 'xss' in action_type or 'burp' in tools_used:
            return 'cross_site_scripting'
        elif 'auth' in action_type or 'login' in target:
            return 'authentication_bypass'
        elif 'ssrf' in action_type or 'localhost' in str(attack_pattern.get('payload', '')):
            return 'server_side_request_forgery'
        elif 'deserial' in action_type or 'pickle' in str(attack_pattern.get('payload', '')):
            return 'insecure_deserialization'
        elif 'exploit' in action_type:
            return 'code_execution'
        else:
            return 'generic_exploit'
    
    def _should_generate_vulnerability(self, attack_pattern: Dict[str, Any]) -> bool:
        """Determine whether to generate a new vulnerability"""
        
        # Don't generate if attack was unsuccessful
        if not attack_pattern.get('success', False):
            return False
        
        # Check novelty threshold
        similarity_scores = []
        for existing_vuln in self.active_vulnerabilities.values():
            similarity = self._calculate_attack_similarity(attack_pattern, existing_vuln)
            similarity_scores.append(similarity)
        
        if similarity_scores:
            max_similarity = max(similarity_scores)
            if max_similarity > self.novelty_threshold:
                return False  # Too similar to existing vulnerability
        
        # Generate with some probability to maintain realism
        generation_probability = self._calculate_generation_probability(attack_pattern)
        return random.random() < generation_probability
    
    def _calculate_attack_similarity(self, attack_pattern: Dict[str, Any], 
                                   vulnerability: GeneratedVulnerability) -> float:
        """Calculate similarity between attack pattern and existing vulnerability"""
        
        # Compare attack type
        attack_type = self._classify_attack_type(attack_pattern)
        vuln_type = vulnerability.vuln_type.value
        
        type_similarity = 1.0 if attack_type in vuln_type else 0.3
        
        # Compare target
        attack_target = attack_pattern.get('target_host', '')
        vuln_target = vulnerability.affected_host
        
        target_similarity = 1.0 if attack_target == vuln_target else 0.5
        
        # Compare payload/technique
        attack_payload = str(attack_pattern.get('payload', ''))
        vuln_payload = vulnerability.payload_template
        
        payload_similarity = self._string_similarity(attack_payload, vuln_payload)
        
        # Weighted average
        overall_similarity = (
            0.4 * type_similarity +
            0.3 * target_similarity +
            0.3 * payload_similarity
        )
        
        return overall_similarity
    
    def _string_similarity(self, str1: str, str2: str) -> float:
        """Calculate similarity between two strings"""
        if not str1 or not str2:
            return 0.0
        
        # Simple character-based similarity
        str1_set = set(str1.lower())
        str2_set = set(str2.lower())
        
        intersection = len(str1_set.intersection(str2_set))
        union = len(str1_set.union(str2_set))
        
        return intersection / union if union > 0 else 0.0
    
    def _calculate_generation_probability(self, attack_pattern: Dict[str, Any]) -> float:
        """Calculate probability of generating a vulnerability"""
        base_probability = 0.3
        
        # Increase probability for sophisticated attacks
        sophistication_bonus = attack_pattern.get('sophistication_score', 0.5) * 0.2
        
        # Increase probability for high-value targets
        target_value = attack_pattern.get('target_value', 0) / 1000000  # Normalize to millions
        value_bonus = min(target_value * 0.1, 0.2)
        
        # Decrease probability if we have many active vulnerabilities
        saturation_penalty = len(self.active_vulnerabilities) * 0.02
        
        final_probability = base_probability + sophistication_bonus + value_bonus - saturation_penalty
        return np.clip(final_probability, 0.05, 0.8)
    
    def _map_attack_to_vulnerability_type(self, attack_type: str) -> VulnerabilityType:
        """Map attack type to vulnerability type"""
        mapping = {
            'sql_injection': VulnerabilityType.INJECTION,
            'cross_site_scripting': VulnerabilityType.XSS,
            'authentication_bypass': VulnerabilityType.BROKEN_AUTH,
            'server_side_request_forgery': VulnerabilityType.SSRF,
            'insecure_deserialization': VulnerabilityType.INSECURE_DESERIAL,
            'code_execution': VulnerabilityType.KNOWN_VULNS,
            'generic_exploit': VulnerabilityType.SECURITY_MISCONFIG
        }
        
        return mapping.get(attack_type, VulnerabilityType.SECURITY_MISCONFIG)
    
    def _generate_vulnerability_id(self, attack_pattern: Dict[str, Any]) -> str:
        """Generate unique vulnerability ID"""
        # Create hash from attack pattern
        pattern_str = json.dumps(attack_pattern, sort_keys=True)
        pattern_hash = hashlib.md5(pattern_str.encode()).hexdigest()[:8]
        
        # Generate CVE-like ID
        year = datetime.now().year
        vuln_id = f"ARCHANGEL-{year}-{pattern_hash.upper()}"
        
        return vuln_id
    
    async def _create_realistic_vulnerability(self, vuln_id: str, vuln_type: VulnerabilityType,
                                            template: Dict[str, Any], target_service: str,
                                            target_host: str, attack_pattern: Dict[str, Any]) -> GeneratedVulnerability:
        """Create a realistic vulnerability with proper details"""
        
        # Select variation based on attack pattern
        variations = template['variations']
        variation = self._select_variation(variations, attack_pattern)
        
        # Generate description
        description = await self._generate_vulnerability_description(
            vuln_type, variation, target_service, attack_pattern
        )
        
        # Calculate severity based on target and impact
        severity = self._calculate_vulnerability_severity(
            vuln_type, target_host, target_service, attack_pattern
        )
        
        # Generate CVSS score
        cvss_score = self._calculate_cvss_score(severity, vuln_type, target_service)
        
        # Generate payload template
        payload_template = self._generate_payload_template(template, variation, attack_pattern)
        
        # Determine complexity factors
        exploit_complexity = self._calculate_exploit_complexity(vuln_type, variation, target_service)
        discovery_difficulty = self._calculate_discovery_difficulty(vuln_type, target_service)
        
        # Generate prerequisites and post-exploit actions
        prerequisites = self._generate_prerequisites(vuln_type, target_service)
        post_exploit_actions = self._generate_post_exploit_actions(vuln_type, attack_pattern)
        
        vulnerability = GeneratedVulnerability(
            vuln_id=vuln_id,
            vuln_type=vuln_type,
            severity=severity,
            affected_service=target_service,
            affected_host=target_host,
            description=description,
            exploit_complexity=exploit_complexity,
            discovery_difficulty=discovery_difficulty,
            payload_template=payload_template,
            prerequisites=prerequisites,
            post_exploit_actions=post_exploit_actions,
            cvss_score=cvss_score,
            generation_method="attack_pattern_analysis",
            parent_attack=attack_pattern.get('attack_id'),
            created_at=datetime.now()
        )
        
        return vulnerability
    
    def _select_variation(self, variations: List[str], attack_pattern: Dict[str, Any]) -> str:
        """Select appropriate variation based on attack pattern"""
        # Simple selection based on attack characteristics
        tools_used = attack_pattern.get('tools', [])
        payload = str(attack_pattern.get('payload', '')).lower()
        
        # Rule-based selection
        if 'union' in payload:
            return next((v for v in variations if 'union' in v), variations[0])
        elif 'time' in payload or 'sleep' in payload:
            return next((v for v in variations if 'time' in v), variations[0])
        elif 'error' in payload:
            return next((v for v in variations if 'error' in v), variations[0])
        else:
            return random.choice(variations)
    
    async def _generate_vulnerability_description(self, vuln_type: VulnerabilityType,
                                                variation: str, target_service: str,
                                                attack_pattern: Dict[str, Any]) -> str:
        """Generate realistic vulnerability description"""
        
        base_descriptions = {
            VulnerabilityType.INJECTION: f"SQL injection vulnerability in {target_service} allows attackers to execute arbitrary SQL commands",
            VulnerabilityType.XSS: f"Cross-site scripting vulnerability in {target_service} allows execution of malicious scripts",
            VulnerabilityType.BROKEN_AUTH: f"Authentication bypass vulnerability in {target_service} allows unauthorized access",
            VulnerabilityType.SSRF: f"Server-side request forgery vulnerability in {target_service} allows internal network access",
            VulnerabilityType.INSECURE_DESERIAL: f"Insecure deserialization in {target_service} leads to remote code execution"
        }
        
        base_desc = base_descriptions.get(vuln_type, f"Security vulnerability in {target_service}")
        
        # Add variation-specific details
        variation_details = {
            'union_select': "via UNION SELECT statements",
            'blind_boolean': "through boolean-based blind techniques",
            'time_based': "using time-based blind injection",
            'reflected': "through reflected XSS in user input",
            'stored': "via stored XSS in persistent data",
            'weak_passwords': "due to weak default credentials",
            'session_fixation': "through session fixation attacks"
        }
        
        detail = variation_details.get(variation, f"using {variation} techniques")
        
        return f"{base_desc} {detail}. "
    
    def _calculate_vulnerability_severity(self, vuln_type: VulnerabilityType, 
                                        target_host: str, target_service: str,
                                        attack_pattern: Dict[str, Any]) -> VulnerabilitySeverity:
        """Calculate vulnerability severity"""
        
        # Base severity by type
        base_severity_map = {
            VulnerabilityType.INJECTION: VulnerabilitySeverity.HIGH,
            VulnerabilityType.XSS: VulnerabilitySeverity.MEDIUM,
            VulnerabilityType.BROKEN_AUTH: VulnerabilityType.HIGH,
            VulnerabilityType.SSRF: VulnerabilitySeverity.MEDIUM,
            VulnerabilityType.INSECURE_DESERIAL: VulnerabilitySeverity.CRITICAL,
            VulnerabilityType.KNOWN_VULNS: VulnerabilitySeverity.HIGH
        }
        
        base_severity = base_severity_map.get(vuln_type, VulnerabilitySeverity.MEDIUM)
        
        # Adjust based on target criticality
        critical_hosts = ['db-server', 'domain-controller', 'financial-db']
        critical_services = ['mysql', 'ldap', 'ssh']
        
        if target_host in critical_hosts or target_service in critical_services:
            # Upgrade severity
            if base_severity == VulnerabilitySeverity.MEDIUM:
                return VulnerabilitySeverity.HIGH
            elif base_severity == VulnerabilitySeverity.HIGH:
                return VulnerabilitySeverity.CRITICAL
        
        return base_severity
    
    def _calculate_cvss_score(self, severity: VulnerabilitySeverity, 
                            vuln_type: VulnerabilityType, target_service: str) -> float:
        """Calculate CVSS score for vulnerability"""
        
        base_scores = {
            VulnerabilitySeverity.CRITICAL: 9.0,
            VulnerabilitySeverity.HIGH: 7.5,
            VulnerabilitySeverity.MEDIUM: 5.5,
            VulnerabilitySeverity.LOW: 3.0,
            VulnerabilitySeverity.INFORMATIONAL: 1.0
        }
        
        base_score = base_scores[severity]
        
        # Add some randomness for realism
        variation = random.uniform(-0.5, 0.5)
        
        final_score = np.clip(base_score + variation, 1.0, 10.0)
        return round(final_score, 1)
    
    def _generate_payload_template(self, template: Dict[str, Any], 
                                 variation: str, attack_pattern: Dict[str, Any]) -> str:
        """Generate payload template for vulnerability"""
        
        base_payload = template['base_payload']
        
        # Modify based on variation
        if variation == 'union_select':
            return f"{base_payload} UNION SELECT version(), user(), database()"
        elif variation == 'time_based':
            return f"{base_payload}; IF(1=1, SLEEP(5), 0)"
        elif variation == 'stored':
            return f"<img src=x onerror={base_payload}>"
        else:
            # Use attack pattern payload if available
            attack_payload = attack_pattern.get('payload')
            if attack_payload and len(str(attack_payload)) > 10:
                return str(attack_payload)
            
            return base_payload
    
    def _calculate_exploit_complexity(self, vuln_type: VulnerabilityType, 
                                    variation: str, target_service: str) -> float:
        """Calculate exploit complexity (0-1 scale, higher = more complex)"""
        
        base_complexity = {
            VulnerabilityType.INJECTION: 0.4,
            VulnerabilityType.XSS: 0.3,
            VulnerabilityType.BROKEN_AUTH: 0.2,
            VulnerabilityType.SSRF: 0.6,
            VulnerabilityType.INSECURE_DESERIAL: 0.8
        }
        
        complexity = base_complexity.get(vuln_type, 0.5)
        
        # Adjust based on variation
        if 'blind' in variation or 'time' in variation:
            complexity += 0.2
        elif 'stored' in variation:
            complexity += 0.1
        
        # Adjust based on service type
        if target_service in ['mysql', 'postgresql']:
            complexity += 0.1  # Database services are more complex
        
        return np.clip(complexity, 0.1, 0.9)
    
    def _calculate_discovery_difficulty(self, vuln_type: VulnerabilityType, 
                                      target_service: str) -> float:
        """Calculate difficulty of discovering vulnerability (0-1 scale)"""
        
        base_difficulty = {
            VulnerabilityType.INJECTION: 0.3,  # Easy to find with scanners
            VulnerabilityType.XSS: 0.2,
            VulnerabilityType.BROKEN_AUTH: 0.1,  # Very obvious
            VulnerabilityType.SSRF: 0.7,  # Harder to discover
            VulnerabilityType.INSECURE_DESERIAL: 0.8  # Very hard to find
        }
        
        difficulty = base_difficulty.get(vuln_type, 0.5)
        
        # Service-specific adjustments
        if target_service == 'http':
            difficulty -= 0.1  # Web services easier to scan
        elif target_service in ['ssh', 'ftp']:
            difficulty += 0.2  # Network services harder to analyze
        
        return np.clip(difficulty, 0.1, 0.9)
    
    def _generate_prerequisites(self, vuln_type: VulnerabilityType, 
                              target_service: str) -> List[str]:
        """Generate prerequisites for exploiting vulnerability"""
        
        prerequisites = []
        
        if vuln_type == VulnerabilityType.INJECTION:
            prerequisites.extend(['network_access', 'sql_knowledge'])
        elif vuln_type == VulnerabilityType.XSS:
            prerequisites.extend(['web_access', 'javascript_knowledge'])
        elif vuln_type == VulnerabilityType.BROKEN_AUTH:
            prerequisites.extend(['account_enumeration', 'credential_testing'])
        elif vuln_type == VulnerabilityType.SSRF:
            prerequisites.extend(['application_access', 'network_mapping'])
        elif vuln_type == VulnerabilityType.INSECURE_DESERIAL:
            prerequisites.extend(['code_analysis', 'serialization_knowledge', 'gadget_chains'])
        
        # Service-specific prerequisites
        if target_service == 'mysql':
            prerequisites.append('database_client')
        elif target_service == 'http':
            prerequisites.append('web_browser')
        
        return prerequisites
    
    def _generate_post_exploit_actions(self, vuln_type: VulnerabilityType,
                                     attack_pattern: Dict[str, Any]) -> List[str]:
        """Generate possible post-exploitation actions"""
        
        actions = []
        
        if vuln_type == VulnerabilityType.INJECTION:
            actions.extend(['data_extraction', 'privilege_escalation', 'lateral_movement'])
        elif vuln_type == VulnerabilityType.XSS:
            actions.extend(['session_hijacking', 'credential_theft', 'phishing'])
        elif vuln_type == VulnerabilityType.BROKEN_AUTH:
            actions.extend(['account_takeover', 'data_access', 'system_access'])
        elif vuln_type == VulnerabilityType.SSRF:
            actions.extend(['internal_scanning', 'service_enumeration', 'cloud_metadata_access'])
        elif vuln_type == VulnerabilityType.INSECURE_DESERIAL:
            actions.extend(['remote_code_execution', 'system_compromise', 'persistence'])
        
        # Add common post-exploit actions
        actions.extend(['log_clearing', 'backdoor_installation', 'data_exfiltration'])
        
        return actions
    
    async def _update_threat_intelligence(self, attack_pattern: Dict[str, Any],
                                        vulnerability: GeneratedVulnerability):
        """Update threat intelligence based on new vulnerability"""
        
        # Extract TTP patterns
        ttp = f"{attack_pattern.get('action_type', 'unknown')}_{vulnerability.vuln_type.value}"
        self.threat_intelligence.ttp_patterns.append(ttp)
        
        # Update attack chains
        if attack_pattern.get('previous_actions'):
            chain = attack_pattern['previous_actions'] + [ttp]
            self.threat_intelligence.attack_chains.append(chain)
        
        # Update payload patterns
        if vulnerability.payload_template:
            self.threat_intelligence.common_payloads.append(vulnerability.payload_template)
        
        # Update target preferences
        target_key = f"{vulnerability.affected_host}:{vulnerability.affected_service}"
        current_preference = self.threat_intelligence.target_preferences.get(target_key, 0)
        self.threat_intelligence.target_preferences[target_key] = current_preference + 1
        
        # Limit size of threat intelligence data
        self._trim_threat_intelligence()
    
    def _trim_threat_intelligence(self):
        """Trim threat intelligence data to prevent unbounded growth"""
        max_items = 1000
        
        if len(self.threat_intelligence.ttp_patterns) > max_items:
            self.threat_intelligence.ttp_patterns = self.threat_intelligence.ttp_patterns[-max_items:]
        
        if len(self.threat_intelligence.attack_chains) > max_items:
            self.threat_intelligence.attack_chains = self.threat_intelligence.attack_chains[-max_items:]
        
        if len(self.threat_intelligence.common_payloads) > max_items:
            self.threat_intelligence.common_payloads = self.threat_intelligence.common_payloads[-max_items:]
    
    async def remove_vulnerability(self, vuln_id: str, reason: str = "patched"):
        """Remove a vulnerability from the active list"""
        if vuln_id in self.active_vulnerabilities:
            vulnerability = self.active_vulnerabilities[vuln_id]
            del self.active_vulnerabilities[vuln_id]
            
            logger.info(f"Removed vulnerability {vuln_id} ({reason})")
            return vulnerability
        
        return None
    
    def get_vulnerabilities_by_host(self, hostname: str) -> List[GeneratedVulnerability]:
        """Get all vulnerabilities affecting a specific host"""
        return [vuln for vuln in self.active_vulnerabilities.values() 
                if vuln.affected_host == hostname]
    
    def get_vulnerabilities_by_type(self, vuln_type: VulnerabilityType) -> List[GeneratedVulnerability]:
        """Get all vulnerabilities of a specific type"""
        return [vuln for vuln in self.active_vulnerabilities.values() 
                if vuln.vuln_type == vuln_type]
    
    def get_threat_intelligence_summary(self) -> Dict[str, Any]:
        """Get summary of current threat intelligence"""
        return {
            'total_ttp_patterns': len(self.threat_intelligence.ttp_patterns),
            'unique_ttp_patterns': len(set(self.threat_intelligence.ttp_patterns)),
            'attack_chains': len(self.threat_intelligence.attack_chains),
            'common_payloads': len(self.threat_intelligence.common_payloads),
            'top_targets': sorted(
                self.threat_intelligence.target_preferences.items(),
                key=lambda x: x[1], reverse=True
            )[:10],
            'active_vulnerabilities': len(self.active_vulnerabilities),
            'vulnerability_types': {
                vtype.value: len(self.get_vulnerabilities_by_type(vtype))
                for vtype in VulnerabilityType
            }
        }

class AdaptiveHardeningEngine:
    """Engine for adaptive security hardening based on vulnerabilities and attacks"""
    
    def __init__(self):
        self.active_hardenings = {}
        self.hardening_history = deque(maxlen=5000)
        self.effectiveness_metrics = defaultdict(float)
        self.cost_benefit_ratios = defaultdict(float)
        
        # Hardening templates
        self.hardening_templates = self._initialize_hardening_templates()
        
        logger.info("Adaptive Hardening Engine initialized")
    
    def _initialize_hardening_templates(self) -> Dict[HardeningMeasure, Dict[str, Any]]:
        """Initialize hardening measure templates"""
        return {
            HardeningMeasure.PATCH_MANAGEMENT: {
                'base_cost': 0.2,
                'base_effectiveness': 0.9,
                'deployment_time': 0.1,
                'applicable_vulns': [VulnerabilityType.KNOWN_VULNS, VulnerabilityType.INJECTION],
                'side_effects': ['service_downtime', 'compatibility_issues']
            },
            
            HardeningMeasure.INPUT_VALIDATION: {
                'base_cost': 0.4,
                'base_effectiveness': 0.8,
                'deployment_time': 0.3,
                'applicable_vulns': [VulnerabilityType.INJECTION, VulnerabilityType.XSS],
                'side_effects': ['false_positives', 'performance_impact']
            },
            
            HardeningMeasure.ACCESS_CONTROL: {
                'base_cost': 0.3,
                'base_effectiveness': 0.85,
                'deployment_time': 0.2,
                'applicable_vulns': [VulnerabilityType.BROKEN_ACCESS, VulnerabilityType.BROKEN_AUTH],
                'side_effects': ['user_friction', 'admin_overhead']
            },
            
            HardeningMeasure.NETWORK_SEGMENTATION: {
                'base_cost': 0.7,
                'base_effectiveness': 0.75,
                'deployment_time': 0.5,
                'applicable_vulns': [VulnerabilityType.SSRF, VulnerabilityType.KNOWN_VULNS],
                'side_effects': ['connectivity_issues', 'management_complexity']
            },
            
            HardeningMeasure.ENCRYPTION: {
                'base_cost': 0.5,
                'base_effectiveness': 0.95,
                'deployment_time': 0.4,
                'applicable_vulns': [VulnerabilityType.SENSITIVE_DATA, VulnerabilityType.CRYPTO_FAILURES],
                'side_effects': ['performance_overhead', 'key_management_complexity']
            },
            
            HardeningMeasure.MONITORING: {
                'base_cost': 0.6,
                'base_effectiveness': 0.7,
                'deployment_time': 0.3,
                'applicable_vulns': list(VulnerabilityType),  # Applies to all
                'side_effects': ['alert_fatigue', 'storage_requirements']
            }
        }
    
    async def generate_hardening_response(self, vulnerability: GeneratedVulnerability,
                                        attack_success: bool,
                                        network_state: Dict[str, Any]) -> Optional[AdaptiveHardening]:
        """Generate adaptive hardening response to vulnerability exploitation"""
        
        # Determine appropriate hardening measures
        applicable_measures = self._get_applicable_measures(vulnerability)
        
        if not applicable_measures:
            return None
        
        # Select best measure based on effectiveness and cost
        selected_measure = self._select_optimal_measure(
            applicable_measures, vulnerability, attack_success, network_state
        )
        
        # Generate hardening configuration
        hardening = await self._create_hardening_implementation(
            selected_measure, vulnerability, network_state
        )
        
        # Store active hardening
        self.active_hardenings[hardening.hardening_id] = hardening
        self.hardening_history.append(hardening)
        
        logger.info(f"Generated hardening {hardening.hardening_id} "
                   f"({selected_measure.value}) for {vulnerability.vuln_id}")
        
        return hardening
    
    def _get_applicable_measures(self, vulnerability: GeneratedVulnerability) -> List[HardeningMeasure]:
        """Get applicable hardening measures for a vulnerability"""
        applicable = []
        
        for measure, template in self.hardening_templates.items():
            if vulnerability.vuln_type in template['applicable_vulns']:
                applicable.append(measure)
        
        return applicable
    
    def _select_optimal_measure(self, applicable_measures: List[HardeningMeasure],
                              vulnerability: GeneratedVulnerability,
                              attack_success: bool,
                              network_state: Dict[str, Any]) -> HardeningMeasure:
        """Select optimal hardening measure based on multiple factors"""
        
        if not applicable_measures:
            return HardeningMeasure.MONITORING  # Default fallback
        
        measure_scores = {}
        
        for measure in applicable_measures:
            template = self.hardening_templates[measure]
            
            # Calculate effectiveness score
            base_effectiveness = template['base_effectiveness']
            
            # Adjust for vulnerability severity
            severity_multiplier = {
                VulnerabilitySeverity.CRITICAL: 1.2,
                VulnerabilitySeverity.HIGH: 1.1,
                VulnerabilitySeverity.MEDIUM: 1.0,
                VulnerabilitySeverity.LOW: 0.9
            }
            effectiveness = base_effectiveness * severity_multiplier[vulnerability.severity]
            
            # Calculate cost score (lower cost = higher score)
            cost_score = 1.0 - template['base_cost']
            
            # Historical effectiveness
            historical_effectiveness = self.effectiveness_metrics.get(measure.value, 0.5)
            
            # Urgency factor (higher if attack was successful)
            urgency_factor = 1.3 if attack_success else 1.0
            
            # Combined score
            total_score = (
                0.4 * effectiveness +
                0.3 * cost_score +
                0.2 * historical_effectiveness +
                0.1
            ) * urgency_factor
            
            measure_scores[measure] = total_score
        
        # Select measure with highest score
        best_measure = max(measure_scores.keys(), key=lambda m: measure_scores[m])
        return best_measure
    
    async def _create_hardening_implementation(self, measure: HardeningMeasure,
                                             vulnerability: GeneratedVulnerability,
                                             network_state: Dict[str, Any]) -> AdaptiveHardening:
        """Create specific hardening implementation"""
        
        hardening_id = f"HARDENING-{measure.value.upper()}-{random.randint(1000, 9999)}"
        template = self.hardening_templates[measure]
        
        # Generate configuration based on measure type
        configuration = await self._generate_hardening_configuration(
            measure, vulnerability, network_state
        )
        
        # Calculate implementation parameters
        implementation_cost = self._calculate_implementation_cost(
            template, vulnerability, network_state
        )
        
        effectiveness_score = self._calculate_effectiveness_score(
            template, vulnerability, network_state
        )
        
        deployment_time = self._calculate_deployment_time(
            template, vulnerability, network_state
        )
        
        success_rate = self._calculate_success_rate(measure, vulnerability)
        
        hardening = AdaptiveHardening(
            hardening_id=hardening_id,
            measure_type=measure,
            target_vulnerability=vulnerability.vuln_id,
            implementation_cost=implementation_cost,
            effectiveness_score=effectiveness_score,
            deployment_time=deployment_time,
            side_effects=template['side_effects'].copy(),
            configuration=configuration,
            success_rate=success_rate,
            applied_at=datetime.now(),
            trigger_event=f"vulnerability_{vulnerability.vuln_id}_detected"
        )
        
        return hardening
    
    async def _generate_hardening_configuration(self, measure: HardeningMeasure,
                                              vulnerability: GeneratedVulnerability,
                                              network_state: Dict[str, Any]) -> Dict[str, Any]:
        """Generate specific configuration for hardening measure"""
        
        config = {}
        
        if measure == HardeningMeasure.INPUT_VALIDATION:
            config.update({
                'validation_rules': self._generate_input_validation_rules(vulnerability),
                'whitelist_patterns': self._generate_whitelist_patterns(vulnerability),
                'sanitization_level': 'strict' if vulnerability.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH] else 'moderate'
            })
        
        elif measure == HardeningMeasure.ACCESS_CONTROL:
            config.update({
                'access_policy': 'deny_by_default',
                'required_permissions': self._generate_required_permissions(vulnerability),
                'authentication_level': 'multi_factor' if vulnerability.severity == VulnerabilitySeverity.CRITICAL else 'strong_password'
            })
        
        elif measure == HardeningMeasure.NETWORK_SEGMENTATION:
            config.update({
                'isolation_level': 'full' if vulnerability.severity == VulnerabilitySeverity.CRITICAL else 'partial',
                'allowed_connections': self._generate_allowed_connections(vulnerability, network_state),
                'firewall_rules': self._generate_firewall_rules(vulnerability)
            })
        
        elif measure == HardeningMeasure.MONITORING:
            config.update({
                'log_level': 'debug' if vulnerability.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH] else 'info',
                'alert_thresholds': self._generate_alert_thresholds(vulnerability),
                'monitored_events': self._generate_monitored_events(vulnerability)
            })
        
        elif measure == HardeningMeasure.ENCRYPTION:
            config.update({
                'encryption_algorithm': 'AES-256-GCM',
                'key_rotation_interval': '30_days',
                'encryption_scope': self._determine_encryption_scope(vulnerability)
            })
        
        return config
    
    def _generate_input_validation_rules(self, vulnerability: GeneratedVulnerability) -> List[str]:
        """Generate input validation rules for vulnerability"""
        rules = []
        
        if vulnerability.vuln_type == VulnerabilityType.INJECTION:
            rules.extend([
                'reject_sql_keywords',
                'escape_special_characters',
                'validate_data_types',
                'length_restrictions'
            ])
        
        elif vulnerability.vuln_type == VulnerabilityType.XSS:
            rules.extend([
                'html_entity_encoding',
                'script_tag_removal',
                'attribute_validation',
                'css_sanitization'
            ])
        
        return rules
    
    def _generate_whitelist_patterns(self, vulnerability: GeneratedVulnerability) -> List[str]:
        """Generate whitelist patterns for input validation"""
        patterns = []
        
        if vulnerability.vuln_type == VulnerabilityType.INJECTION:
            patterns.extend([
                '^[a-zA-Z0-9_-]+$',  # Alphanumeric with underscores and hyphens
                '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'  # Email pattern
            ])
        
        return patterns
    
    def _generate_required_permissions(self, vulnerability: GeneratedVulnerability) -> List[str]:
        """Generate required permissions for access control"""
        permissions = []
        
        if vulnerability.affected_service == 'mysql':
            permissions.extend(['database_read', 'database_write'])
        elif vulnerability.affected_service == 'http':
            permissions.extend(['web_access', 'authenticated_user'])
        
        # Add elevated permissions for critical vulnerabilities
        if vulnerability.severity == VulnerabilitySeverity.CRITICAL:
            permissions.append('admin_approval_required')
        
        return permissions
    
    def _generate_allowed_connections(self, vulnerability: GeneratedVulnerability,
                                    network_state: Dict[str, Any]) -> List[str]:
        """Generate allowed network connections"""
        connections = []
        
        # Allow necessary business connections
        if vulnerability.affected_host == 'web-server':
            connections.extend(['client_networks', 'load_balancer'])
        elif vulnerability.affected_host == 'db-server':
            connections.extend(['web-server', 'backup_server'])
        
        return connections
    
    def _generate_firewall_rules(self, vulnerability: GeneratedVulnerability) -> List[str]:
        """Generate firewall rules for network segmentation"""
        rules = []
        
        if vulnerability.vuln_type == VulnerabilityType.SSRF:
            rules.extend([
                'block_internal_networks',
                'restrict_outbound_http',
                'deny_metadata_services'
            ])
        
        elif vulnerability.vuln_type == VulnerabilityType.INJECTION:
            rules.extend([
                'rate_limit_database_connections',
                'block_suspicious_queries'
            ])
        
        return rules
    
    def _generate_alert_thresholds(self, vulnerability: GeneratedVulnerability) -> Dict[str, Any]:
        """Generate alert thresholds for monitoring"""
        thresholds = {}
        
        if vulnerability.severity == VulnerabilitySeverity.CRITICAL:
            thresholds = {
                'failed_attempts': 3,
                'time_window': '5_minutes',
                'escalation_time': '1_minute'
            }
        elif vulnerability.severity == VulnerabilitySeverity.HIGH:
            thresholds = {
                'failed_attempts': 5,
                'time_window': '10_minutes',
                'escalation_time': '5_minutes'
            }
        else:
            thresholds = {
                'failed_attempts': 10,
                'time_window': '30_minutes',
                'escalation_time': '15_minutes'
            }
        
        return thresholds
    
    def _generate_monitored_events(self, vulnerability: GeneratedVulnerability) -> List[str]:
        """Generate list of events to monitor"""
        events = ['login_attempts', 'privilege_escalations', 'data_access']
        
        if vulnerability.vuln_type == VulnerabilityType.INJECTION:
            events.extend(['sql_queries', 'database_errors', 'union_statements'])
        elif vulnerability.vuln_type == VulnerabilityType.XSS:
            events.extend(['script_injections', 'html_modifications', 'cookie_access'])
        
        return events
    
    def _determine_encryption_scope(self, vulnerability: GeneratedVulnerability) -> List[str]:
        """Determine what should be encrypted"""
        scope = []
        
        if vulnerability.vuln_type == VulnerabilityType.SENSITIVE_DATA:
            scope.extend(['data_at_rest', 'data_in_transit', 'database_fields'])
        elif vulnerability.vuln_type == VulnerabilityType.CRYPTO_FAILURES:
            scope.extend(['communication_channels', 'stored_credentials', 'session_tokens'])
        
        return scope
    
    def _calculate_implementation_cost(self, template: Dict[str, Any],
                                     vulnerability: GeneratedVulnerability,
                                     network_state: Dict[str, Any]) -> float:
        """Calculate implementation cost"""
        base_cost = template['base_cost']
        
        # Adjust for network complexity
        network_complexity = len(network_state.get('hosts', [])) / 10.0
        complexity_factor = 1.0 + (network_complexity * 0.1)
        
        # Adjust for vulnerability severity (critical = more expensive to fix properly)
        severity_factor = {
            VulnerabilitySeverity.CRITICAL: 1.3,
            VulnerabilitySeverity.HIGH: 1.1,
            VulnerabilitySeverity.MEDIUM: 1.0,
            VulnerabilitySeverity.LOW: 0.9
        }
        
        final_cost = base_cost * complexity_factor * severity_factor[vulnerability.severity]
        return np.clip(final_cost, 0.1, 1.0)
    
    def _calculate_effectiveness_score(self, template: Dict[str, Any],
                                     vulnerability: GeneratedVulnerability,
                                     network_state: Dict[str, Any]) -> float:
        """Calculate expected effectiveness score"""
        base_effectiveness = template['base_effectiveness']
        
        # Historical effectiveness
        historical = self.effectiveness_metrics.get(template, 0.5)
        
        # Weighted combination
        final_effectiveness = 0.7 * base_effectiveness + 0.3 * historical
        
        return np.clip(final_effectiveness, 0.1, 1.0)
    
    def _calculate_deployment_time(self, template: Dict[str, Any],
                                 vulnerability: GeneratedVulnerability,
                                 network_state: Dict[str, Any]) -> float:
        """Calculate deployment time"""
        base_time = template['deployment_time']
        
        # Adjust for network size
        network_size_factor = len(network_state.get('hosts', [])) / 5.0
        
        final_time = base_time * (1.0 + network_size_factor * 0.1)
        return np.clip(final_time, 0.05, 1.0)
    
    def _calculate_success_rate(self, measure: HardeningMeasure,
                              vulnerability: GeneratedVulnerability) -> float:
        """Calculate probability of successful hardening implementation"""
        
        # Base success rates by measure type
        base_rates = {
            HardeningMeasure.PATCH_MANAGEMENT: 0.95,
            HardeningMeasure.INPUT_VALIDATION: 0.85,
            HardeningMeasure.ACCESS_CONTROL: 0.90,
            HardeningMeasure.NETWORK_SEGMENTATION: 0.75,
            HardeningMeasure.ENCRYPTION: 0.80,
            HardeningMeasure.MONITORING: 0.90
        }
        
        base_rate = base_rates.get(measure, 0.8)
        
        # Adjust for vulnerability complexity
        complexity_penalty = vulnerability.exploit_complexity * 0.1
        
        final_rate = base_rate - complexity_penalty
        return np.clip(final_rate, 0.5, 0.99)
    
    async def update_hardening_effectiveness(self, hardening_id: str,
                                           actual_effectiveness: float):
        """Update effectiveness metrics based on actual results"""
        if hardening_id in self.active_hardenings:
            hardening = self.active_hardenings[hardening_id]
            measure_type = hardening.measure_type.value
            
            # Update effectiveness metrics using exponential moving average
            current_avg = self.effectiveness_metrics[measure_type]
            alpha = 0.1  # Learning rate
            
            self.effectiveness_metrics[measure_type] = (
                alpha * actual_effectiveness + (1 - alpha) * current_avg
            )
            
            logger.info(f"Updated effectiveness for {measure_type}: {self.effectiveness_metrics[measure_type]:.3f}")
    
    def get_hardening_summary(self) -> Dict[str, Any]:
        """Get summary of hardening activities"""
        if not self.active_hardenings:
            return {'active_hardenings': 0}
        
        hardenings = list(self.active_hardenings.values())
        
        # Group by measure type
        by_type = defaultdict(int)
        for hardening in hardenings:
            by_type[hardening.measure_type.value] += 1
        
        # Calculate average effectiveness
        avg_effectiveness = np.mean([h.effectiveness_score for h in hardenings])
        
        # Calculate total cost
        total_cost = sum(h.implementation_cost for h in hardenings)
        
        return {
            'active_hardenings': len(hardenings),
            'by_type': dict(by_type),
            'average_effectiveness': avg_effectiveness,
            'total_cost': total_cost,
            'effectiveness_metrics': dict(self.effectiveness_metrics),
            'recent_hardenings': len([h for h in hardenings 
                                    if (datetime.now() - h.applied_at).days < 1])
        }

# Integration class that combines both engines
class AdaptiveSecurityOrchestrator:
    """Orchestrates dynamic vulnerability generation and adaptive hardening"""
    
    def __init__(self):
        self.vuln_engine = DynamicVulnerabilityEngine()
        self.hardening_engine = AdaptiveHardeningEngine()
        self.orchestration_history = deque(maxlen=1000)
        
        logger.info("Adaptive Security Orchestrator initialized")
    
    async def process_attack_event(self, attack_pattern: Dict[str, Any],
                                 network_state: Dict[str, Any]) -> Dict[str, Any]:
        """Process an attack event and generate appropriate responses"""
        
        response = {
            'new_vulnerability': None,
            'hardening_response': None,
            'threat_level_change': 0,
            'recommendations': []
        }
        
        # Generate new vulnerability if warranted
        new_vuln = await self.vuln_engine.generate_vulnerability_from_attack(
            attack_pattern, network_state
        )
        
        if new_vuln:
            response['new_vulnerability'] = asdict(new_vuln)
            
            # Generate hardening response
            attack_success = attack_pattern.get('success', False)
            hardening = await self.hardening_engine.generate_hardening_response(
                new_vuln, attack_success, network_state
            )
            
            if hardening:
                response['hardening_response'] = asdict(hardening)
        
        # Update threat level
        response['threat_level_change'] = self._calculate_threat_level_change(
            attack_pattern, new_vuln
        )
        
        # Generate recommendations
        response['recommendations'] = await self._generate_recommendations(
            attack_pattern, new_vuln, network_state
        )
        
        # Store in history
        self.orchestration_history.append({
            'timestamp': datetime.now(),
            'attack_pattern': attack_pattern,
            'response': response
        })
        
        return response
    
    def _calculate_threat_level_change(self, attack_pattern: Dict[str, Any],
                                     vulnerability: Optional[GeneratedVulnerability]) -> float:
        """Calculate change in threat level"""
        base_change = 0.1 if attack_pattern.get('success', False) else 0.0
        
        if vulnerability:
            severity_impact = {
                VulnerabilitySeverity.CRITICAL: 0.4,
                VulnerabilitySeverity.HIGH: 0.3,
                VulnerabilitySeverity.MEDIUM: 0.2,
                VulnerabilitySeverity.LOW: 0.1
            }
            base_change += severity_impact.get(vulnerability.severity, 0.1)
        
        return base_change
    
    async def _generate_recommendations(self, attack_pattern: Dict[str, Any],
                                      vulnerability: Optional[GeneratedVulnerability],
                                      network_state: Dict[str, Any]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        if vulnerability:
            recommendations.append(f"Immediately address {vulnerability.vuln_id} on {vulnerability.affected_host}")
            
            if vulnerability.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]:
                recommendations.append("Consider emergency patching procedures")
            
            if vulnerability.exploit_complexity < 0.3:
                recommendations.append("Vulnerability is easily exploitable - prioritize remediation")
        
        # Attack pattern recommendations
        if attack_pattern.get('coordination_detected'):
            recommendations.append("Coordinated attack detected - review incident response procedures")
        
        if attack_pattern.get('novel_technique'):
            recommendations.append("Novel attack technique observed - update detection signatures")
        
        return recommendations
    
    def get_security_posture_summary(self) -> Dict[str, Any]:
        """Get comprehensive security posture summary"""
        vuln_summary = self.vuln_engine.get_threat_intelligence_summary()
        hardening_summary = self.hardening_engine.get_hardening_summary()
        
        return {
            'vulnerabilities': vuln_summary,
            'hardenings': hardening_summary,
            'orchestration_events': len(self.orchestration_history),
            'recent_activity': len([event for event in self.orchestration_history
                                  if (datetime.now() - event['timestamp']).hours < 24])
        }

# Example usage
if __name__ == "__main__":
    async def test_dynamic_systems():
        """Test the dynamic vulnerability and hardening systems"""
        orchestrator = AdaptiveSecurityOrchestrator()
        
        # Simulate attack patterns
        attack_patterns = [
            {
                'attack_id': 'attack_001',
                'action_type': 'sql_injection',
                'target_host': 'db-server',
                'target_service': 'mysql',
                'success': True,
                'payload': "' UNION SELECT version() --",
                'tools': ['sqlmap'],
                'sophistication_score': 0.7
            },
            {
                'attack_id': 'attack_002',
                'action_type': 'xss_attempt',
                'target_host': 'web-server',
                'target_service': 'http',
                'success': True,
                'payload': "<script>alert('XSS')</script>",
                'tools': ['burpsuite'],
                'sophistication_score': 0.5
            }
        ]
        
        network_state = {
            'hosts': ['web-server', 'db-server', 'file-server'],
            'services': ['http', 'mysql', 'ftp'],
            'asset_values': {
                'db-server': 2000000,
                'web-server': 500000,
                'file-server': 1000000
            }
        }
        
        # Process attacks
        for attack in attack_patterns:
            response = await orchestrator.process_attack_event(attack, network_state)
            
            print(f"\nProcessed attack {attack['attack_id']}:")
            print(f"  New vulnerability: {response['new_vulnerability'] is not None}")
            print(f"  Hardening response: {response['hardening_response'] is not None}")
            print(f"  Threat level change: +{response['threat_level_change']:.2f}")
            print(f"  Recommendations: {len(response['recommendations'])}")
        
        # Get summary
        summary = orchestrator.get_security_posture_summary()
        print("\nSecurity Posture Summary:")
        print(json.dumps(summary, indent=2, default=str))
    
    # Run test
    asyncio.run(test_dynamic_systems())